<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paritalk - Private Chat</title>

    <!-- Preconnect to Firebase, Supabase, and Google Fonts -->
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://www.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://uokpkgybjzvpngoxasnm.supabase.co" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">

    <!-- Tailwind CSS (assuming it's loaded via CDN or local build) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Socket.IO Client CDN - CRITICAL FIX -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>
<body>
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <p class="loading-text">Loading chat...</p>
    </div>

    <div class="chat-app-container-premium" id="chat-app-container">
        <header class="chat-header-premium">
            <div class="chat-header-info">
                <span class="material-symbols-outlined chat-header-avatar-icon">account_circle</span>
                <div class="chat-header-details">
                    <h1 class="chat-room-display-name" id="room-code-display">Room Code</h1>
                    <span class="chat-online-users-count" id="online-users-count">
                        <span class="status-dot"></span> <span id="user-count-text">0 online</span>
                    </span>
                </div>
            </div>
            <div class="chat-header-actions">
                <span class="material-symbols-outlined chat-action-icon" id="video-call-button" title="Start Video Call">videocam</span>
                <span class="material-symbols-outlined chat-action-icon" id="leave-room-button" title="Leave Room">exit_to_app</span>
            </div>
        </header>

        <main class="messages-container-premium" id="messages-container">
            </main>

        <div class="typing-indicator-premium hidden" id="typing-indicator">
            <span id="typing-username"></span> is typing<span>.</span><span>.</span><span>.</span>
        </div>

        <footer class="message-input-area-premium">
            <input type="file" id="file-input" class="hidden" accept="image/*, application/pdf">
            <span class="material-symbols-outlined attach-file-button" id="attach-file-button" title="Attach File">attach_file</span>
            <input type="text" id="message-input" class="input-field-premium" placeholder="Type a message...">
            <button id="send-message-button" class="send-message-button" title="Send Message">
                <span class="material-symbols-outlined">send</span>
            </button>
        </footer>

        <!-- WebRTC Video Call Overlay -->
        <div id="webrtc-call-overlay" class="webrtc-call-overlay hidden">
            <div class="webrtc-main-video-wrapper">
                <video id="remote-video" class="webrtc-main-video" autoplay playsinline></video>
                <div id="remote-video-placeholder" class="webrtc-video-placeholder">
                    <div class="loading-spinner"></div>
                    <p class="mt-4 text-gray-300">Waiting for peer to join...</p>
                </div>
                <div class="webrtc-video-label" id="remote-label">Other User</div>
            </div>

            <div id="local-video-pip-wrapper" class="webrtc-local-video-pip-wrapper">
                <video id="local-video" class="webrtc-local-video" autoplay playsinline muted></video>
                <div class="webrtc-video-label" id="local-label">You</div>
            </div>

            <div class="webrtc-controls">
                <button id="toggle-mic-button" class="webrtc-control-button">
                    <span class="material-symbols-outlined">mic</span>
                </button>
                <button id="toggle-camera-button" class="webrtc-control-button">
                    <span class="material-symbols-outlined">videocam</span>
                </button>
                <button id="hangup-webrtc-button" class="webrtc-control-button hangup-button">
                    <span class="material-symbols-outlined">call_end</span>
                </button>
                <button id="toggle-pip-button" class="webrtc-control-button">
                    <span class="material-symbols-outlined maximize-icon">open_in_full</span>
                    <span class="material-symbols-outlined minimize-icon hidden">close_fullscreen</span>
                </button>
            </div>

            <p id="webrtc-status-message" class="webrtc-status-message"></p>
        </div>

        <!-- Incoming Call UI -->
        <div id="incoming-call-modal" class="incoming-call-modal hidden">
            <div class="incoming-call-content">
                <span class="material-symbols-outlined incoming-call-icon">phone_in_talk</span>
                <p id="caller-name-display" class="caller-name-display">Incoming call from...</p>
                <div class="incoming-call-actions">
                    <button id="reject-call-button" class="call-action-button reject">
                        <span class="material-symbols-outlined">call_end</span>
                    </button>
                    <button id="accept-call-button" class="call-action-button accept">
                        <span class="material-symbols-outlined">call</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="full-media-modal hidden" id="full-media-modal">
            <button class="full-media-close-button" id="full-media-close-button" title="Close">
                <span class="material-symbols-outlined">close</span>
            </button>
            <div class="full-media-content-premium">
                <div class="full-media-display-area" id="full-media-display-area">
                    </div>
                <div class="full-media-controls" id="full-media-controls">
                    <a id="full-media-download-button" class="full-media-download-button" download>
                        <span class="material-symbols-outlined">download</span> Download
                    </a>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div class="modal-premium hidden" id="confirmation-modal">
            <div class="modal-content-premium">
                <p class="modal-message-text-premium" id="modal-message"></p>
                <div class="modal-buttons-premium">
                    <button class="modal-button-premium confirm-button-premium" id="modal-confirm">Confirm</button>
                    <button class="modal-button-premium cancel-button-premium" id="modal-cancel">Cancel</button>
                </div>
            </div>
        </div>

    </div> <!-- Close chat-app-container-premium -->

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getDatabase, ref, push, onValue, set, serverTimestamp, remove, onDisconnect, query, limitToLast, orderByChild, off, get } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // Import the new WebRTC client logic
        // THIS IS THE CORRECTED LINE: only import what is actually exported.
        import { initWebRTCClient, hangupCall, toggleLocalAudio, toggleLocalVideo, acceptCall, rejectCall, initiateCall } from './main_webrtc.js';


        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8Yj1Z1Mpv2lyt9SRxJ_w4U04BXt8hajk", // Your Firebase API Key
            authDomain: "paritalk.firebaseapp.com",
            projectId: "paritalk",
            databaseURL: "https://paritalk-default-rtdb.firebaseio.com",
            storageBucket: "paritalk.firebasestorage.app",
            messagingSenderId: "441945619664",
            appId: "1:441945619664:web:045e0c872e67e0eb9fb2d5"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        const storage = getStorage(app);

        // Supabase Configuration (ONLY ONE DECLARATION HERE)
        const SUPABASE_URL = 'https://uokpkgybjzvpngoxasnm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVva3BrZ3lianp2cG5nb3hhc25tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5MjE4NTcsImV4cCI6MjA2NTQ5Nzg1N30.FNv_13S3oj7fjartmY2PzKL25T3AWbMxP2KRI0rFU2E';
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);


        // DOM Elements
        const loadingOverlay = document.getElementById('loading-overlay');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const onlineUsersCountSpan = document.getElementById('online-users-count');
        const userCountText = document.getElementById('user-count-text');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendMessageButton = document.getElementById('send-message-button');
        const videoCallButton = document.getElementById('video-call-button');
        const leaveRoomButton = document.getElementById('leave-room-button');
        const attachFileButton = document.getElementById('attach-file-button');
        const fileInput = document.getElementById('file-input');
        const fullMediaModal = document.getElementById('full-media-modal');
        const fullMediaCloseButton = document.getElementById('full-media-close-button');
        const fullMediaDisplayArea = document.getElementById('full-media-display-area');
        const fullMediaDownloadButton = document.getElementById('full-media-download-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const typingUsernameSpan = document.getElementById('typing-username');

        // Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmButton = document.getElementById('modal-confirm');
        const modalCancelButton = document.getElementById('modal-cancel');

        // WebRTC Video Call UI Elements
        const webrtcCallOverlay = document.getElementById('webrtc-call-overlay');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const remoteVideoPlaceholder = document.getElementById('remote-video-placeholder');
        const remoteLabel = document.getElementById('remote-label');
        const localLabel = document.getElementById('local-label');
        const webrtcStatusMessage = document.getElementById('webrtc-status-message');
        const toggleMicButton = document.getElementById('toggle-mic-button');
        const toggleCameraButton = document.getElementById('toggle-camera-button');
        const hangupWebrtcButton = document.getElementById('hangup-webrtc-button');
        const togglePipButton = document.getElementById('toggle-pip-button');
        const maximizePipIcon = togglePipButton.querySelector('.maximize-icon');
        const minimizePipIcon = togglePipButton.querySelector('.minimize-icon');
        const localVideoPipWrapper = document.getElementById('local-video-pip-wrapper');

        // Incoming Call UI elements
        const incomingCallModal = document.getElementById('incoming-call-modal');
        const callerNameDisplay = document.getElementById('caller-name-display');
        const rejectCallButton = document.getElementById('reject-call-button');
        const acceptCallButton = document.getElementById('accept-call-button');


        // Global Variables
        let currentUserId = null; // Firebase Auth UID for the current user
        let currentUsername = null;
        let currentRoomCode = null;
        let messagesRef = null;
        let presenceRef = null; // Firebase RTDB ref for current user's presence
        let typingRef = null;
        let otherUserTypingRef = null;
        let otherUserId = null; // This will hold the Firebase Auth UID of the other person in the room
        let typingTimeout = null;
        let currentCallId = null; // The unique ID for the ongoing/incoming video call session
        let isPipMode = false; // To control Picture-in-Picture state
        // rtcClientInstance is not explicitly stored here, as we only need the exported functions directly.

        // Firebase reference for call invitations within this chat room
        // Declared here globally to be accessible by the onValue listener and other functions
        let callInvitesListenerRef = null;


        // --- Utility Functions ---

        // Show Confirmation Modal
        async function showConfirmationModal(message) {
            modalMessage.textContent = message;
            confirmationModal.classList.remove('hidden');
            confirmationModal.style.display = 'flex';

            return new Promise((resolve) => {
                const confirmListener = () => {
                    confirmationModal.classList.add('hidden');
                    confirmationModal.style.display = 'none';
                    modalConfirmButton.removeEventListener('click', confirmListener);
                    modalCancelButton.removeEventListener('click', cancelListener);
                    resolve(true);
                };

                const cancelListener = () => {
                    confirmationModal.classList.add('hidden');
                    confirmationModal.style.display = 'none';
                    modalConfirmButton.removeEventListener('click', confirmListener);
                    modalCancelButton.removeEventListener('click', cancelListener);
                    resolve(false);
                };

                modalConfirmButton.addEventListener('click', confirmListener);
                modalCancelButton.addEventListener('click', cancelListener);
            });
        }

        // Auto-scroll messages to bottom
        function scrollToBottom() {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // --- Core Chat Functions ---

        // Display Message in UI
        function displayMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message-bubble-premium');

            if (message.type === 'system') {
                if (message.action === 'videoCallEnded') {
                    messageElement.classList.add('system-message-premium', 'system-message-with-action');
                    messageElement.innerHTML = `
                        <p>${message.text}</p>
                        <span class="material-symbols-outlined" style="font-size: 20px; color: var(--color-error); margin-top: 5px;">call_end</span>
                    `;
                }
                 else {
                    messageElement.classList.add('system-message-premium');
                    messageElement.textContent = message.text;
                }
            } else {
                messageElement.classList.add(message.senderId === currentUserId ? 'mine-bubble-premium' : 'other-bubble-premium');

                let contentHTML = `<span class="message-content-premium">${message.text || ''}</span>`;

                if (message.file) {
                    if (message.file.type.startsWith('image/')) {
                        contentHTML = `
                            <div class="message-image-preview" data-url="${message.file.url}" data-type="${message.file.type}">
                                <img src="${message.file.url}" alt="Image" class="message-image-premium-thumb">
                                <span class="material-symbols-outlined message-media-overlay-icon">zoom_in</span>
                            </div>
                        `;
                    } else {
                        contentHTML = `
                            <div class="message-file-premium-preview" data-url="${message.file.url}" data-type="${message.file.type}" data-name="${message.file.name}">
                                <span class="material-symbols-outlined file-icon">attach_file</span>
                                <a href="${message.file.url}" target="_blank" rel="noopener noreferrer" class="file-name-link">${message.file.name}</a>
                                <a href="${message.file.url}" download="${message.file.name}" class="download-icon">
                                    <span class="material-symbols-outlined">download</span>
                                </span>
                            </div>
                        `;
                    }
                }

                messageElement.innerHTML = `
                    ${contentHTML}
                    <div class="message-info-footer-premium">
                        <span class="message-sender-name-bottom">${message.senderName}</span>
                        <span class="message-timestamp-premium">${formatTimestamp(message.timestamp)}</span>
                    </div>
                `;
            }

            messagesContainer.appendChild(messageElement);
            scrollToBottom();
        }


        // Send Message
        async function sendMessage(text = '', file = null) {
            if ((!text && !file) || (text.trim() === '' && !file)) {
                return;
            }

            const message = {
                senderId: currentUserId,
                senderName: currentUsername,
                text: text.trim(),
                timestamp: serverTimestamp(),
                type: 'text',
                readBy: {
                    [currentUserId]: true
                }
            };

            if (file) {
                message.type = file.type.startsWith('image/') ? 'image' : 'file';
                message.file = {
                    name: file.name,
                    url: file.url,
                    type: file.type,
                    size: file.size
                };
            }

            try {
                await push(messagesRef, message);
                messageInput.value = '';
                if (file) fileInput.value = '';
                updateTypingStatus(false);
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }

        // --- Presence & Typing Status ---

        // Setup User Presence
        async function setupPresence() {
            presenceRef = ref(db, `rooms/${currentRoomCode}/presence/${currentUserId}`);
            await set(presenceRef, { username: currentUsername, isTyping: false, lastOnline: serverTimestamp(), userId: currentUserId });
            console.log(`Presence set for ${currentUsername} in ${currentRoomCode}.`);

            // Crucial: Set up onDisconnect to remove presence when user disconnects or tab closes
            onDisconnect(presenceRef).remove()
                .then(() => {
                    console.log("onDisconnect handler successfully set for presence.");
                })
                .catch((error) => {
                    console.error("Error setting onDisconnect for presence:", error);
                });
        }

        // Update Online Users Count
        function updateOnlineUsersCount() {
            const roomPresenceRef = ref(db, `rooms/${currentRoomCode}/presence`);
            onValue(roomPresenceRef, (snapshot) => {
                const onlineUsers = snapshot.val();
                const count = onlineUsers ? Object.keys(onlineUsers).length : 0;
                userCountText.textContent = `${count} online`;
                console.log(`Online users count updated: ${count}`);

                // Determine otherUserId for typing indicator and call recipient
                let newOtherUserId = null;
                let otherUsernameDisplay = 'Other User'; // Default display
                if (onlineUsers) {
                    const onlineUserIds = Object.keys(onlineUsers);
                    newOtherUserId = onlineUserIds.find(id => id !== currentUserId);
                    if (newOtherUserId && onlineUsers[newOtherUserId]) {
                        otherUsernameDisplay = onlineUsers[newOtherUserId].username;
                        console.log("Other user's username updated to:", otherUsernameDisplay); // Added for debugging
                    }
                }

                if (newOtherUserId && newOtherUserId !== otherUserId) {
                    console.log("Other user ID changed/found:", newOtherUserId);
                    if (otherUserTypingRef) {
                        off(otherUserTypingRef);
                        console.log("Detached old typing listener.");
                    }
                    otherUserId = newOtherUserId;
                    setupTypingIndicator(otherUserId, otherUsernameDisplay); // Pass username for display
                } else if (!newOtherUserId && otherUserId) {
                    console.log("Other user left.");
                    if (otherUserTypingRef) {
                        off(otherUserTypingRef);
                        console.log("Detached typing listener for removed user.");
                    }
                    otherUserId = null;
                    typingIndicator.classList.add('hidden');
                } else if (!newOtherUserId && !otherUserId) {
                    typingIndicator.classList.add('hidden');
                }
            });
        }

        // Update own typing status in Firebase
        async function updateTypingStatus(isTyping) {
            console.log(`Setting typing status to: ${isTyping}`);
            if (!typingRef) {
                typingRef = ref(db, `rooms/${currentRoomCode}/presence/${currentUserId}/isTyping`);
            }
            try {
                await set(typingRef, isTyping);
                console.log(`Typing status successfully set to ${isTyping} in Firebase.`);
            } catch (error) {
                console.error("Error setting typing status:", error);
            }
        }

        // Setup typing indicator for OTHER user
        function setupTypingIndicator(idOfOtherUser, otherUsername) {
            if (!idOfOtherUser) {
                console.log("No other user ID provided for typing indicator setup.");
                typingIndicator.classList.add('hidden');
                return;
            }

            otherUserTypingRef = ref(db, `rooms/${currentRoomCode}/presence/${idOfOtherUser}/isTyping`);

            console.log(`Listening for typing status of other user: ${idOfOtherUser}`);

            onValue(otherUserTypingRef, (snapshot) => {
                const isOtherUserTyping = snapshot.val();
                console.log(`Other user typing status changed: ${isOtherUserTyping}`);

                if (isOtherUserTyping) {
                    typingUsernameSpan.textContent = otherUsername;
                    typingIndicator.classList.remove('hidden');
                    console.log(`Typing indicator shown for: ${otherUsername}`);
                } else {
                    typingIndicator.classList.add('hidden');
                    console.log("Typing indicator hidden.");
                }
            });
        }


        // --- File Upload & Media Display ---

        // Upload File to Supabase Storage
        async function uploadFile(file) {
            const filePath = `files/${currentRoomCode}/${Date.now()}_${file.name}`;
            const { data, error } = await supabase.storage
                .from('paritalk-files')
                .upload(filePath, file, {
                    cacheControl: '3600',
                    upsert: false
                });

            if (error) {
                console.error("Supabase file upload failed:", error);
                throw error;
            }

            const { data: publicUrlData } = supabase.storage
                .from('paritalk-files')
                .getPublicUrl(filePath);

            if (publicUrlData && publicUrlData.publicUrl) {
                return {
                    name: file.name,
                    url: publicUrlData.publicUrl,
                    type: file.type,
                    size: file.size
                };
            } else {
                throw new Error("Failed to get public URL for uploaded file.");
            }
        }

        // Show Full Media Modal
        function showFullMediaModal(url, type, fileName) {
            fullMediaDisplayArea.innerHTML = '';
            fullMediaDownloadButton.href = url;
            fullMediaDownloadButton.download = fileName || 'download';

            if (type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = url;
                img.classList.add('full-media-image');
                fullMediaDisplayArea.appendChild(img);
            } else if (type.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = url;
                video.controls = true;
                video.autoplay = true;
                video.classList.add('full-media-video');
                fullMediaDisplayArea.appendChild(video);
            } else if (type === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.classList.add('full-media-document');
                iframe.setAttribute('frameborder', '0');
                fullMediaDisplayArea.appendChild(iframe);
            } else {
                const infoText = document.createElement('p');
                infoText.classList.add('full-media-info-text');
                infoText.textContent = `File type not previewable: ${fileName}`;
                fullMediaDisplayArea.appendChild(infoText);
            }

            fullMediaModal.classList.remove('hidden');
            fullMediaModal.style.display = 'flex';
        }

        // Close Full Media Modal
        function closeFullMediaModal() {
            fullMediaModal.classList.add('hidden');
            fullMediaModal.style.display = 'none';
            fullMediaDisplayArea.innerHTML = '';
            const video = fullMediaDisplayArea.querySelector('video');
            if (video) {
                video.pause();
                video.currentTime = 0;
            }
        }


        // --- WebRTC Video Call Control (Integrated) ---

        // Callbacks from main_webrtc.js to update chat.html UI
        const webrtcUiCallbacks = {
            onStatusUpdate: (message) => {
                webrtcStatusMessage.textContent = message;
            },
            onLocalStream: (stream) => {
                localVideo.srcObject = stream;
                if (localVideo.classList.contains('hidden')) {
                    localVideo.classList.remove('hidden');
                }
            },
            onRemoteStream: (stream, peerUsername) => {
                remoteVideo.srcObject = stream;
                remoteVideoPlaceholder.classList.add('hidden');
                remoteVideo.classList.remove('hidden');
                remoteLabel.textContent = peerUsername || 'Other User';
            },
            onRemoteStreamEnded: () => {
                remoteVideo.srcObject = null;
                remoteVideo.classList.add('hidden');
                remoteVideoPlaceholder.classList.remove('hidden');
                remoteLabel.textContent = 'Other User';
            },
            onCallEnded: () => {
                webrtcCallOverlay.classList.add('hidden');
                webrtcCallOverlay.classList.remove('pip-mode');
                isPipMode = false;
                if (maximizePipIcon) maximizePipIcon.classList.remove('hidden');
                if (minimizePipIcon) minimizePipIcon.classList.add('hidden');

                // Only post "ended" message if there was an actual call ID
                if (currentCallId) {
                    push(messagesRef, {
                        type: 'system',
                        action: 'videoCallEnded',
                        text: `${currentUsername} ended the video call.`,
                        callId: currentCallId,
                        timestamp: serverTimestamp()
                    });
                    // Clean up Firebase invite status for us and the other user AFTER the message
                    if (currentUserId) {
                        remove(ref(db, `rooms/${currentRoomCode}/callInvites/${currentUserId}`));
                    }
                    if (otherUserId) { // Only try to remove other user's invite if `otherUserId` is known
                        remove(ref(db, `rooms/${currentRoomCode}/callInvites/${otherUserId}`));
                    }
                    currentCallId = null; // Clear the call ID
                }
                webrtcStatusMessage.textContent = '';
            },
            onMicrophoneToggle: (isMuted) => {
                toggleMicButton.querySelector('.material-symbols-outlined').textContent = isMuted ? 'mic_off' : 'mic';
            },
            onCameraToggle: (isOff) => {
                toggleCameraButton.querySelector('.material-symbols-outlined').textContent = isOff ? 'videocam_off' : 'videocam';
            },
            onIncomingCall: (callerChatUserId, callerUsername, callID) => {
                console.log(`Incoming call from ${callerUsername} (${callerChatUserId}) for call ID ${callID}`);
                currentCallId = callID; // Set the current call ID for the incoming call
                callerNameDisplay.textContent = `Incoming call from ${callerUsername}`;
                incomingCallModal.classList.remove('hidden');
            },
            onCallCancelled: () => {
                incomingCallModal.classList.add('hidden');
                currentCallId = null;
                console.log("Incoming call cancelled by caller.");
                // Corrected: Use callInvitesListenerRef directly for cleanup
                if (currentUserId && callInvitesListenerRef) {
                    remove(callInvitesListenerRef);
                }
            },
            onCallRejected: (rejecterUsername) => {
                console.log(`Call rejected by ${rejecterUsername}.`);
                incomingCallModal.classList.add('hidden');
                currentCallId = null;
                // Corrected: Use callInvitesListenerRef directly for cleanup
                if (currentUserId && callInvitesListenerRef) {
                    remove(callInvitesListenerRef);
                }
            }
        };

        // IMPORTANT: Replace this with YOUR CODESPACES SIGNALING SERVER URL
        const SIGNALING_SERVER_URL = "https://crispy-spork-g4pxrgrp655gh94rr-5000.app.github.dev/";

        async function startWebRTCCall(initialCallId = null, isInitiator = true) {
            incomingCallModal.classList.add('hidden');
            webrtcCallOverlay.classList.remove('hidden'); // Show call overlay immediately
            remoteVideoPlaceholder.classList.remove('hidden');
            remoteVideo.srcObject = null;
            remoteVideo.classList.add('hidden');

            currentCallId = initialCallId || `${currentRoomCode}-${Date.now()}`;

            // Initialize/re-initialize the WebRTC client for this specific call ID
            // This sets up the Socket.IO connection to the correct signaling room.
            // initWebRTCClient no longer requests media immediately.
            initWebRTCClient(
                SIGNALING_SERVER_URL,
                currentUsername,
                currentUserId,   // Firebase chat user ID
                currentCallId, // The signaling room will be this unique call ID
                webrtcUiCallbacks,
                { localVideoElement: localVideo, remoteVideoElement: remoteVideo }
            );


            if (isInitiator) {
                if (otherUserId) {
                    // Send an invite to Firebase to prompt the other user's chat.html
                    const inviteRefForRecipient = ref(db, `rooms/${currentRoomCode}/callInvites/${otherUserId}`);
                    await set(inviteRefForRecipient, {
                        callId: currentCallId,
                        callerId: currentUserId,
                        callerUsername: currentUsername,
                        recipientId: otherUserId,
                        status: 'pending',
                        timestamp: serverTimestamp()
                    });

                    await push(messagesRef, {
                        type: 'system',
                        action: 'videoCallStarted',
                        text: `${currentUsername} started a video call.`,
                        callId: currentCallId,
                        timestamp: serverTimestamp(),
                        initiatorId: currentUserId,
                        recipientId: otherUserId
                    });

                    // Call the initiateCall function from main_webrtc.js to get media and start offer process
                    initiateCall(currentCallId); // Pass only the callId to initiateCall
                    const otherUserPresenceRef = ref(db, `rooms/${currentRoomCode}/presence/${otherUserId}/username`);
                    const otherUserSnapshot = await get(otherUserPresenceRef);
                    const otherUsernameDisplay = otherUserSnapshot.exists() ? otherUserSnapshot.val() : 'Other User';
                    webrtcStatusMessage.textContent = `Calling ${otherUsernameDisplay}...`;

                } else {
                    webrtcUiCallbacks.onStatusUpdate('No other user online to call.');
                    showConfirmationModal('Cannot start call: No other user online in this room.');
                    hangupCall(); // Hangup any partially started WebRTC client
                }
            }
            // If not initiator (i.e., accepting), the main_webrtc.js will handle joining the room and media via acceptCall
        }


        function togglePipMode() {
            isPipMode = !isPipMode;
            webrtcCallOverlay.classList.toggle('pip-mode', isPipMode);
            // Toggle icons
            if (maximizePipIcon) maximizePipIcon.classList.remove('hidden', isPipMode); // Show maximize if not PIP, hide if PIP
            if (minimizePipIcon) minimizePipIcon.classList.toggle('hidden', !isPipMode); // Show minimize if PIP, hide if not PIP

            // Reset PIP position when maximizing to ensure it's not stuck off-screen
            if (!isPipMode) {
                localVideoPipWrapper.style.left = '';
                localVideoPipWrapper.style.top = '';
            }
        }

        // Local Video PIP Dragging
        let isDraggingPip = false;
        let pipOffsetX = 0;
        let pipOffsetY = 0;

        localVideoPipWrapper.addEventListener('mousedown', (e) => {
            if (isPipMode) { // Only draggable in PIP mode
                isDraggingPip = true;
                pipOffsetX = e.clientX - localVideoPipWrapper.getBoundingClientRect().left;
                pipOffsetY = e.clientY - localVideoPipWrapper.getBoundingClientRect().top;
                localVideoPipWrapper.style.cursor = 'grabbing';
                // Prevent text selection during drag
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingPip) return;
            // Calculate new position relative to the viewport
            let newX = e.clientX - pipOffsetX;
            let newY = e.clientY - pipOffsetY;

            // Constrain movement to within the webrtcCallOverlay bounds
            const overlayRect = webrtcCallOverlay.getBoundingClientRect();
            const pipRect = localVideoPipWrapper.getBoundingClientRect();

            // Calculate new X and Y relative to the overlay's top-left corner
            // Ensure PIP doesn't go outside the overlay's bounds
            let finalX = Math.max(0, Math.min(newX - overlayRect.left, overlayRect.width - pipRect.width));
            let finalY = Math.max(0, Math.min(newY - overlayRect.top, overlayRect.height - pipRect.height));

            localVideoPipWrapper.style.left = `${finalX}px`;
            localVideoPipWrapper.style.top = `${finalY}px`;
        });

        document.addEventListener('mouseup', () => {
            isDraggingPip = false;
            localVideoPipWrapper.style.cursor = 'grab';
        });

        // --- Event Listeners ---

        sendMessageButton.addEventListener('click', () => {
            sendMessage(messageInput.value);
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage(messageInput.value);
            }
        });

        messageInput.addEventListener('input', () => {
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            updateTypingStatus(true);
            typingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 3000);
        });

        messageInput.addEventListener('blur', () => {
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            updateTypingStatus(false);
        });

        // Main "Start Video Call" button
        videoCallButton.addEventListener('click', async () => {
            const confirmed = await showConfirmationModal('Are you sure you want to start a video call?');
            if (confirmed) {
                if (otherUserId) {
                    startWebRTCCall(null, true); // Initiates a new call, with isInitiator = true
                } else {
                    webrtcUiCallbacks.onStatusUpdate('No other user online to call.');
                    showConfirmationModal('Cannot start call: No other user online in this room.');
                }
            }
        });

        // WebRTC Control Buttons
        toggleMicButton.addEventListener('click', () => {
            // No need to check rtcClientInstance here, as functions are directly imported
            toggleLocalAudio();
        });
        toggleCameraButton.addEventListener('click', () => {
            // No need to check rtcClientInstance here, as functions are directly imported
            toggleLocalVideo();
        });
        hangupWebrtcButton.addEventListener('click', () => {
            // No need to check rtcClientInstance here, as functions are directly imported
            hangupCall(); // Use the imported hangupCall
        });
        togglePipButton.addEventListener('click', togglePipMode);

        // Incoming Call Action Buttons
        rejectCallButton.addEventListener('click', () => {
            if (currentCallId) { // Only reject if there's an active incoming call
                rejectCall(currentCallId); // Pass the callId to rejectCall
            }
            incomingCallModal.classList.add('hidden');
            currentCallId = null;
        });

        acceptCallButton.addEventListener('click', () => {
            if (currentCallId) { // Only accept if there's an an active incoming call
                // `acceptCall` function in main_webrtc.js will now handle media and peer connection creation.
                acceptCall(currentCallId);
                incomingCallModal.classList.add('hidden');
            }
        });


        if (leaveRoomButton) {
            leaveRoomButton.addEventListener('click', handleLeaveRoom);
            console.log("Leave Room button event listener attached.");
        } else {
            console.error("Leave Room button element not found!");
        }

        attachFileButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log("Uploading file:", file.name);
                try {
                    const uploadedFileDetails = await uploadFile(file);
                    await sendMessage('', uploadedFileDetails);
                    console.log("File message sent!");
                } catch (error) {
                    console.error("Failed to upload or send file:", error);
                    alert("Failed to send file. Please try again.");
                } finally {
                    fileInput.value = '';
                }
            }
        });

        messagesContainer.addEventListener('click', async (event) => {
            const imagePreview = event.target.closest('.message-image-preview');
            const filePreview = event.target.closest('.message-file-premium-preview');
            const downloadIcon = event.target.closest('.download-icon');

            if (imagePreview) {
                const url = imagePreview.dataset.url;
                const type = imagePreview.dataset.type;
                showFullMediaModal(url, type);
            } else if (filePreview && !downloadIcon) {
                const url = filePreview.dataset.url;
                const type = filePreview.dataset.type;
                const name = filePreview.dataset.name;
                showFullMediaModal(url, type, name);
            }
        });

        fullMediaCloseButton.addEventListener('click', closeFullMediaModal);

        // --- Initialization ---

        function getQueryParams() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const regex = /([^&=]+)=([^&]*)/g;
            let m;
            while ((m = regex.exec(queryString))) {
                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            return params;
        }

        const queryParams = getQueryParams();
        currentRoomCode = queryParams.room;
        currentUsername = queryParams.user;

        if (!currentRoomCode || !currentUsername) {
            alert('Room code or username missing. Redirecting to login.');
            window.location.href = 'index.html';
        } else {
            roomCodeDisplay.textContent = currentRoomCode;
            messagesRef = ref(db, `rooms/${currentRoomCode}/messages`);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    console.log("Authenticated with Firebase UID:", currentUserId);

                    await setupPresence(); // Set up presence and onDisconnect
                    updateOnlineUsersCount(); // This also sets `otherUserId` and triggers typing listener

                    // Initialize the WebRTC client primarily for Socket.IO connection management.
                    // This sets up the socket but DOES NOT request media immediately.
                    initWebRTCClient(
                        SIGNALING_SERVER_URL,
                        currentUsername,
                        currentUserId,   // Firebase chat user ID
                        `initial_room_for_${currentUserId}`, // Dummy call ID for initial socket connection/registration
                        webrtcUiCallbacks,
                        { localVideoElement: localVideo, remoteVideoElement: remoteVideo }
                    );

                    // Listen for incoming call invitations from other users in the same Firebase chat room
                    callInvitesListenerRef = ref(db, `rooms/${currentRoomCode}/callInvites/${currentUserId}`);
                    onValue(callInvitesListenerRef, async (snapshot) => {
                        const invite = snapshot.val();
                        // Only process if it's a pending invite and not from ourselves
                        if (invite && invite.status === 'pending' && invite.callerId !== currentUserId) {
                            console.log("Firebase: Received pending call invite:", invite);
                            // It's crucial to re-init the WebRTC client with the specific callId from the invite
                            // This ensures the Socket.IO connection joins the correct signaling room for the call.
                            initWebRTCClient(
                                SIGNALING_SERVER_URL,
                                currentUsername,
                                currentUserId,
                                invite.callId, // Use the specific call ID from the invite as the signaling room
                                webrtcUiCallbacks,
                                { localVideoElement: localVideo, remoteVideoElement: remoteVideo }
                            );

                            webrtcUiCallbacks.onIncomingCall(invite.callerId, invite.callerUsername, invite.callId);

                            // Set the invite status to 'received' to acknowledge it, preventing re-trigger
                            // Use callInvitesListenerRef directly for updates
                            await set(callInvitesListenerRef, { ...invite, status: 'received' });
                        } else if (invite && invite.status === 'cancelled') {
                             webrtcUiCallbacks.onCallCancelled();
                             // The onCallCancelled callback already handles removing callInvitesListenerRef
                        } else if (invite && invite.status === 'rejected') {
                             webrtcUiCallbacks.onCallRejected(invite.rejecterUsername);
                             // The onCallRejected callback already handles removing callInvitesListenerRef
                        }
                    });


                    onValue(query(messagesRef, limitToLast(50), orderByChild('timestamp')), (snapshot) => {
                        messagesContainer.innerHTML = '';
                        snapshot.forEach((childSnapshot) => {
                            displayMessage(childSnapshot.val());
                        });
                        scrollToBottom();
                        loadingOverlay.classList.add('hidden');
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 300);
                    });

                    await push(messagesRef, {
                        type: 'system',
                        text: `${currentUsername} has joined the chat room.`,
                        timestamp: serverTimestamp()
                    });

                } else {
                    console.error("No user authenticated. Redirecting to login.");
                    alert('Authentication failed. Please log in again.');
                    window.location.href = 'index.html';
                }
            });
        }


        async function handleLeaveRoom() {
            console.log("Entering handleLeaveRoom function.");

            const confirmed = await showConfirmationModal('Are you sure you want to leave the chat room?');
            if (!confirmed) {
                console.log("Leave room cancelled by user.");
                return;
            }

            console.log("Proceeding to leave the room.");
            if (presenceRef && currentUserId) {
                console.log("presenceRef is valid:", presenceRef.toString());
                console.log("currentUserId is valid:", currentUserId);
                try {
                    // Cancel the onDisconnect handler immediately before manually removing presence
                    await onDisconnect(presenceRef).cancel();
                    await remove(presenceRef);
                    console.log("SUCCESS: User presence explicitly removed from room:", currentRoomCode);

                    await push(messagesRef, {
                        type: 'system',
                        text: `${currentUsername} has left the chat room.`,
                        timestamp: serverTimestamp()
                    });

                    // Clear any pending call invites initiated by us or sent to us in Firebase
                    if (otherUserId) {
                        remove(ref(db, `rooms/${currentRoomCode}/callInvites/${otherUserId}`));
                    }
                    if (callInvitesListenerRef) {
                       remove(callInvitesListenerRef); // Use the properly scoped ref for cleanup
                    }


                } catch (error) {
                    console.error("ERROR: Failed to remove presence on leave:", error);
                    alert("Failed to perform all leave operations. Check console for details, then you'll be redirected.");
                }
            } else {
                console.warn("WARNING: presenceRef or currentUserId not available. Cannot remove presence.");
            }
            // Ensure WebRTC call is ended if active
            if (webrtcCallOverlay && !webrtcCallOverlay.classList.contains('hidden')) {
                hangupCall(); // This will also handle signaling server disconnect
            }
            localStorage.removeItem('paritalk_username');
            localStorage.removeItem('paritalk_roomcode');
            console.log("Local storage cleared.");
            window.location.href = 'index.html';
            console.log("Redirecting to index.html...");
        }


        window.addEventListener('beforeunload', async (e) => {
            // This listener should ideally trigger onDisconnect, but explicit cleanup is good.
            // Firebase's onDisconnect is more reliable for abrupt closures.
            // No need for explicit `set(presenceRef, null)` here as onDisconnect handles it.
            // If the call is active, explicitly hang up.
            if (webrtcCallOverlay && !webrtcCallOverlay.classList.contains('hidden')) {
                hangupCall();
            }
            localStorage.removeItem('paritalk_username');
            localStorage.removeItem('paritalk_roomcode');
            console.log("Local storage cleared on beforeunload.");
        });

    </script>
</body>
</html>
