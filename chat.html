<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paritalk - Private Chat</title>

    <!-- Preconnect to Firebase, Supabase, and Google Fonts for faster loading -->
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://www.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://uokpkgybjzvpngoxasnm.supabase.co" crossorigin>
    <link rel="preconnect" href="https://meet.jit.si" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">

</head>
<body>
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <p class="loading-text">Loading chat...</p>
    </div>

    <div class="chat-app-container-premium" id="chat-app-container">
        <header class="chat-header-premium">
            <div class="chat-header-info">
                <span class="material-symbols-outlined chat-header-avatar-icon">account_circle</span>
                <div class="chat-header-details">
                    <h1 class="chat-room-display-name" id="room-code-display">Room Code</h1>
                    <span class="chat-online-users-count" id="online-users-count">
                        <span class="status-dot"></span> <span id="user-count-text">0 online</span>
                    </span>
                </div>
            </div>
            <div class="chat-header-actions">
                <span class="material-symbols-outlined chat-action-icon" id="video-call-button" title="Start Video Call">videocam</span>
                <span class="material-symbols-outlined chat-action-icon" id="leave-room-button" title="Leave Room">exit_to_app</span>
            </div>
        </header>

        <main class="messages-container-premium" id="messages-container">
            </main>

        <div class="typing-indicator-premium hidden" id="typing-indicator">
            <span id="typing-username"></span> is typing<span>.</span><span>.</span><span>.</span>
        </div>

        <footer class="message-input-area-premium">
            <input type="file" id="file-input" class="hidden" accept="image/*, application/pdf">
            <span class="material-symbols-outlined attach-file-button" id="attach-file-button" title="Attach File">attach_file</span>
            <input type="text" id="message-input" class="input-field-premium" placeholder="Type a message...">
            <button id="send-message-button" class="send-message-button" title="Send Message">
                <span class="material-symbols-outlined">send</span>
            </button>
        </footer>

        <div class="jitsi-container-premium hidden" id="jitsi-container">
            <div id="jitsi-meet-api"></div>
            <div class="jitsi-controls-premium">
                <button class="hangup-button-premium" id="hangup-button">
                    <span class="material-symbols-outlined">call_end</span>
                    Hang Up
                </button>
            </div>
        </div>

        <div class="full-media-modal hidden" id="full-media-modal">
            <button class="full-media-close-button" id="full-media-close-button" title="Close">
                <span class="material-symbols-outlined">close</span>
            </button>
            <div class="full-media-content-premium">
                <div class="full-media-display-area" id="full-media-display-area">
                    </div>
                <div class="full-media-controls" id="full-media-controls">
                    <a id="full-media-download-button" class="full-media-download-button" download>
                        <span class="material-symbols-outlined">download</span> Download
                    </a>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div class="modal-premium hidden" id="confirmation-modal">
            <div class="modal-content-premium">
                <p class="modal-message-text-premium" id="modal-message"></p>
                <div class="modal-buttons-premium">
                    <button class="modal-button-premium confirm-button-premium" id="modal-confirm">Confirm</button>
                    <button class="modal-button-premium cancel-button-premium" id="modal-cancel">Cancel</button>
                </div>
            </div>
        </div>

    </div> <!-- Close chat-app-container-premium -->

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getDatabase, ref, push, onValue, set, serverTimestamp, remove, onDisconnect, query, limitToLast, orderByChild, off } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // Import Jitsi video call functions from the new file
        import { loadJitsiScript, initializeJitsiInstance, hangUpCall } from './jitsi_video_call.js';


        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8Yj1Z1Mpv2lyt9SRxJ_w4U04BXt8hajk", // Your Firebase API Key
            authDomain: "paritalk.firebaseapp.com",
            projectId: "paritalk",
            databaseURL: "https://paritalk-default-rtdb.firebaseio.com",
            storageBucket: "paritalk.firebasestorage.app",
            messagingSenderId: "441945619664",
            appId: "1:441945619664:web:045e0c872e67e0eb9fb2d5"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        const storage = getStorage(app);

        // Supabase Configuration
        const SUPABASE_URL = 'https://uokpkgybjzvpngoxasnm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVva3BrZ3lianp2cG5nb3hhc25tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5MjE4NTcsImV4cCI6MjA2NTQ5Nzg1N30.FNv_13S3oj7fjartmY2PzKL25T3AWbMxP2KRI0rFU2E';

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);


        // DOM Elements
        const loadingOverlay = document.getElementById('loading-overlay');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const onlineUsersCountSpan = document.getElementById('online-users-count');
        const userCountText = document.getElementById('user-count-text');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendMessageButton = document.getElementById('send-message-button');
        const videoCallButton = document.getElementById('video-call-button');
        const leaveRoomButton = document.getElementById('leave-room-button');
        const jitsiContainer = document.getElementById('jitsi-container'); // This is the main Jitsi UI container
        const hangupButton = document.getElementById('hangup-button');
        const attachFileButton = document.getElementById('attach-file-button');
        const fileInput = document.getElementById('file-input');
        const fullMediaModal = document.getElementById('full-media-modal');
        const fullMediaCloseButton = document.getElementById('full-media-close-button');
        const fullMediaDisplayArea = document.getElementById('full-media-display-area');
        const fullMediaDownloadButton = document.getElementById('full-media-download-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const typingUsernameSpan = document.getElementById('typing-username');

        // Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmButton = document.getElementById('modal-confirm');
        const modalCancelButton = document.getElementById('modal-cancel');


        // Global Variables
        let currentUserId = null;
        let currentUsername = null;
        let currentRoomCode = null;
        let messagesRef = null;
        let presenceRef = null;
        let typingRef = null;
        let otherUserTypingRef = null;
        let otherUserId = null;
        let typingTimeout = null;
        let currentCallId = null;

        // --- Utility Functions ---

        // Show Confirmation Modal
        async function showConfirmationModal(message) {
            modalMessage.textContent = message;
            confirmationModal.classList.remove('hidden');
            confirmationModal.style.display = 'flex';

            return new Promise((resolve) => {
                const confirmListener = () => {
                    confirmationModal.classList.add('hidden');
                    confirmationModal.style.display = 'none';
                    modalConfirmButton.removeEventListener('click', confirmListener);
                    modalCancelButton.removeEventListener('click', cancelListener);
                    resolve(true);
                };

                const cancelListener = () => {
                    confirmationModal.classList.add('hidden');
                    confirmationModal.style.display = 'none';
                    modalConfirmButton.removeEventListener('click', confirmListener);
                    modalCancelButton.removeEventListener('click', cancelListener);
                    resolve(false);
                };

                modalConfirmButton.addEventListener('click', confirmListener);
                modalCancelButton.addEventListener('click', cancelListener);
            });
        }

        // Auto-scroll messages to bottom
        function scrollToBottom() {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // --- Core Chat Functions ---

        // Display Message in UI
        function displayMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message-bubble-premium');

            if (message.type === 'system') {
                if (message.action === 'videoCallStarted') {
                    messageElement.classList.add('system-message-premium', 'system-message-with-action');
                    messageElement.innerHTML = `
                        <p>${message.text}</p>
                        <button class="join-call-button" data-call-id="${message.callId}">
                            <span class="material-symbols-outlined">videocam</span>
                            Join Video Call
                        </button>
                    `;
                } else if (message.action === 'videoCallEnded') {
                    messageElement.classList.add('system-message-premium', 'system-message-with-action');
                    messageElement.innerHTML = `
                        <p>${message.text}</p>
                        <span class="material-symbols-outlined" style="font-size: 20px; color: var(--color-error); margin-top: 5px;">call_end</span>
                    `;
                }
                 else {
                    messageElement.classList.add('system-message-premium');
                    messageElement.textContent = message.text;
                }
            } else {
                messageElement.classList.add(message.senderId === currentUserId ? 'mine-bubble-premium' : 'other-bubble-premium');

                let contentHTML = `<span class="message-content-premium">${message.text || ''}</span>`;

                if (message.file) {
                    if (message.file.type.startsWith('image/')) {
                        contentHTML = `
                            <div class="message-image-preview" data-url="${message.file.url}" data-type="${message.file.type}">
                                <img src="${message.file.url}" alt="Image" class="message-image-premium-thumb">
                                <span class="material-symbols-outlined message-media-overlay-icon">zoom_in</span>
                            </div>
                        `;
                    } else {
                        contentHTML = `
                            <div class="message-file-premium-preview" data-url="${message.file.url}" data-type="${message.file.type}" data-name="${message.file.name}">
                                <span class="material-symbols-outlined file-icon">attach_file</span>
                                <a href="${message.file.url}" target="_blank" rel="noopener noreferrer" class="file-name-link">${message.file.name}</a>
                                <a href="${message.file.url}" download="${message.file.name}" class="download-icon">
                                    <span class="material-symbols-outlined">download</span>
                                </span>
                            </div>
                        `;
                    }
                }

                messageElement.innerHTML = `
                    ${contentHTML}
                    <div class="message-info-footer-premium">
                        <span class="message-sender-name-bottom">${message.senderName}</span>
                        <span class="message-timestamp-premium">${formatTimestamp(message.timestamp)}</span>
                    </div>
                `;
            }

            messagesContainer.appendChild(messageElement);
            scrollToBottom();
        }


        // Send Message
        async function sendMessage(text = '', file = null) {
            if ((!text && !file) || (text.trim() === '' && !file)) {
                return;
            }

            const message = {
                senderId: currentUserId,
                senderName: currentUsername,
                text: text.trim(),
                timestamp: serverTimestamp(),
                type: 'text',
                readBy: {
                    [currentUserId]: true
                }
            };

            if (file) {
                message.type = file.type.startsWith('image/') ? 'image' : 'file';
                message.file = {
                    name: file.name,
                    url: file.url,
                    type: file.type,
                    size: file.size
                };
            }

            try {
                await push(messagesRef, message);
                messageInput.value = '';
                if (file) fileInput.value = '';
                updateTypingStatus(false);
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }

        // --- Presence & Typing Status ---

        // Setup User Presence
        async function setupPresence() {
            presenceRef = ref(db, `rooms/${currentRoomCode}/presence/${currentUserId}`);
            await set(presenceRef, { username: currentUsername, isTyping: false, lastOnline: serverTimestamp() });
            console.log(`Presence set for ${currentUsername} in ${currentRoomCode}`);
            onDisconnect(presenceRef).remove();
        }

        // Update Online Users Count
        function updateOnlineUsersCount() {
            const roomPresenceRef = ref(db, `rooms/${currentRoomCode}/presence`);
            onValue(roomPresenceRef, (snapshot) => {
                const onlineUsers = snapshot.val();
                const count = onlineUsers ? Object.keys(onlineUsers).length : 0;
                userCountText.textContent = `${count} online`;
                console.log(`Online users count updated: ${count}`);

                // Determine otherUserId for typing indicator
                if (onlineUsers) {
                    const onlineUserIds = Object.keys(onlineUsers);
                    const newOtherUserId = onlineUserIds.find(id => id !== currentUserId);

                    if (newOtherUserId && newOtherUserId !== otherUserId) {
                        console.log("Other user ID changed/found:", newOtherUserId);
                        if (otherUserTypingRef) {
                            off(otherUserTypingRef);
                            console.log("Detached old typing listener.");
                        }
                        otherUserId = newOtherUserId;
                        setupTypingIndicator(otherUserId);
                    } else if (!newOtherUserId && otherUserId) {
                        console.log("Other user left.");
                        if (otherUserTypingRef) {
                            off(otherUserTypingRef);
                            console.log("Detached typing listener for removed user.");
                        }
                        otherUserId = null;
                        typingIndicator.classList.add('hidden');
                    } else if (!newOtherUserId && !otherUserId) {
                        typingIndicator.classList.add('hidden');
                    }
                } else {
                    if (otherUserTypingRef) {
                        off(otherUserTypingRef);
                        console.log("Detached typing listener as no users online.");
                    }
                    otherUserId = null;
                    typingIndicator.classList.add('hidden');
                }
            });
        }

        // Update own typing status in Firebase
        async function updateTypingStatus(isTyping) {
            console.log(`Setting typing status to: ${isTyping}`);
            if (!typingRef) {
                typingRef = ref(db, `rooms/${currentRoomCode}/presence/${currentUserId}/isTyping`);
            }
            try {
                await set(typingRef, isTyping);
                console.log(`Typing status successfully set to ${isTyping} in Firebase.`);
            } catch (error) {
                console.error("Error setting typing status:", error);
            }
        }

        // Setup typing indicator for OTHER user
        function setupTypingIndicator(idOfOtherUser) {
            if (!idOfOtherUser) {
                console.log("No other user ID provided for typing indicator setup.");
                typingIndicator.classList.add('hidden');
                return;
            }

            otherUserTypingRef = ref(db, `rooms/${currentRoomCode}/presence/${idOfOtherUser}/isTyping`);
            const otherUsernameRef = ref(db, `rooms/${currentRoomCode}/presence/${idOfOtherUser}/username`);

            console.log(`Listening for typing status of other user: ${idOfOtherUser}`);

            onValue(otherUserTypingRef, (snapshot) => {
                const isOtherUserTyping = snapshot.val();
                console.log(`Other user typing status changed: ${isOtherUserTyping}`);

                if (isOtherUserTyping) {
                    onValue(otherUsernameRef, (nameSnapshot) => {
                        const otherUserName = nameSnapshot.val();
                        if (otherUserName) {
                            typingUsernameSpan.textContent = otherUserName;
                            typingIndicator.classList.remove('hidden');
                            console.log(`Typing indicator shown for: ${otherUserName}`);
                        }
                    }, { onlyOnce: true });
                } else {
                    typingIndicator.classList.add('hidden');
                    console.log("Typing indicator hidden.");
                }
            });
        }


        // --- File Upload & Media Display ---

        // Upload File to Supabase Storage
        async function uploadFile(file) {
            const filePath = `files/${currentRoomCode}/${Date.now()}_${file.name}`;
            const { data, error } = await supabase.storage
                .from('paritalk-files')
                .upload(filePath, file, {
                    cacheControl: '3600',
                    upsert: false
                });

            if (error) {
                console.error("Supabase file upload failed:", error);
                throw error;
            }

            const { data: publicUrlData } = supabase.storage
                .from('paritalk-files')
                .getPublicUrl(filePath);

            if (publicUrlData && publicUrlData.publicUrl) {
                return {
                    name: file.name,
                    url: publicUrlData.publicUrl,
                    type: file.type,
                    size: file.size
                };
            } else {
                throw new Error("Failed to get public URL for uploaded file.");
            }
        }

        // Show Full Media Modal
        function showFullMediaModal(url, type, fileName) {
            fullMediaDisplayArea.innerHTML = '';
            fullMediaDownloadButton.href = url;
            fullMediaDownloadButton.download = fileName || 'download';

            if (type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = url;
                img.classList.add('full-media-image');
                fullMediaDisplayArea.appendChild(img);
            } else if (type.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = url;
                video.controls = true;
                video.autoplay = true;
                video.classList.add('full-media-video');
                fullMediaDisplayArea.appendChild(video);
            } else if (type === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.classList.add('full-media-document');
                iframe.setAttribute('frameborder', '0');
                fullMediaDisplayArea.appendChild(iframe);
            } else {
                const infoText = document.createElement('p');
                infoText.classList.add('full-media-info-text');
                infoText.textContent = `File type not previewable: ${fileName}`;
                fullMediaDisplayArea.appendChild(infoText);
            }

            fullMediaModal.classList.remove('hidden');
            fullMediaModal.style.display = 'flex';
        }

        // Close Full Media Modal
        function closeFullMediaModal() {
            fullMediaModal.classList.add('hidden');
            fullMediaModal.style.display = 'none';
            fullMediaDisplayArea.innerHTML = '';
            const video = fullMediaDisplayArea.querySelector('video');
            if (video) {
                video.pause();
                video.currentTime = 0;
            }
        }


        // --- Jitsi Integration Callbacks and Handlers for chat.html ---

        // Callback when Jitsi conference ends or needs to be closed
        function onJitsiConferenceEnded() {
            console.log("onJitsiConferenceEnded triggered. Hiding Jitsi container.");
            jitsiContainer.classList.add('hidden');
            jitsiContainer.style.display = 'none';
            // Also ensure to clear currentCallId if it was active
            if (currentCallId) {
                push(messagesRef, {
                    type: 'system',
                    action: 'videoCallEnded',
                    text: `${currentUsername} ended the video call.`,
                    callId: currentCallId,
                    timestamp: serverTimestamp()
                });
                currentCallId = null;
            }
        }

        // Callback for Jitsi errors to display in chat.html's modal
        function onJitsiConferenceError(errorMessage) {
            console.error("Jitsi Error Handler:", errorMessage);
            showConfirmationModal(`Video Call Error: ${errorMessage || 'Unknown error.'}`);
            // Force hangup if an error occurs to reset state
            hangUpCall(onJitsiConferenceEnded); // Use the imported hangUpCall
        }

        async function handleStartVideoCall() {
            const confirmed = await showConfirmationModal('Are you sure you want to start a video call?');
            if (!confirmed) {
                console.log("Video call initiation cancelled by user.");
                return;
            }

            try {
                // Use the imported loadJitsiScript function
                await loadJitsiScript();

                // Generate a unique call ID for this session
                const callId = `${currentRoomCode}-${Date.now()}`;
                currentCallId = callId;

                // Add system message to chat that video call has started
                await push(messagesRef, {
                    type: 'system',
                    action: 'videoCallStarted',
                    text: `${currentUsername} started a video call.`,
                    callId: callId,
                    timestamp: serverTimestamp()
                });

                // Use the imported initializeJitsiInstance function
                initializeJitsiInstance(currentRoomCode, currentUsername, jitsiContainer, onJitsiConferenceEnded, onJitsiConferenceError);

            } catch (error) {
                console.error("Error preparing for video call:", error);
                onJitsiConferenceError('Could not start video call. Check console for details.');
            }
        }


        // --- Event Listeners ---

        sendMessageButton.addEventListener('click', () => {
            sendMessage(messageInput.value);
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage(messageInput.value);
            }
        });

        messageInput.addEventListener('input', () => {
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            updateTypingStatus(true);
            typingTimeout = setTimeout(() => {
                updateTypingStatus(false);
            }, 3000);
        });

        messageInput.addEventListener('blur', () => {
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            updateTypingStatus(false);
        });

        // Use the new handleStartVideoCall wrapper
        videoCallButton.addEventListener('click', handleStartVideoCall);

        // Use the imported hangUpCall, passing the callback for UI cleanup
        hangupButton.addEventListener('click', () => hangUpCall(onJitsiConferenceEnded));

        if (leaveRoomButton) {
            leaveRoomButton.addEventListener('click', handleLeaveRoom);
            console.log("Leave Room button event listener attached.");
        } else {
            console.error("Leave Room button element not found!");
        }

        attachFileButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log("Uploading file:", file.name);
                try {
                    const uploadedFileDetails = await uploadFile(file);
                    await sendMessage('', uploadedFileDetails);
                    console.log("File message sent!");
                } catch (error) {
                    console.error("Failed to upload or send file:", error);
                    alert("Failed to send file. Please try again.");
                } finally {
                    fileInput.value = '';
                }
            }
        });

        messagesContainer.addEventListener('click', async (event) => {
            const imagePreview = event.target.closest('.message-image-preview');
            const filePreview = event.target.closest('.message-file-premium-preview');
            const downloadIcon = event.target.closest('.download-icon');
            const joinCallButton = event.target.closest('.join-call-button');

            if (imagePreview) {
                const url = imagePreview.dataset.url;
                const type = imagePreview.dataset.type;
                showFullMediaModal(url, type);
            } else if (filePreview && !downloadIcon) {
                const url = filePreview.dataset.url;
                const type = filePreview.dataset.type;
                const name = filePreview.dataset.name;
                showFullMediaModal(url, type, name);
            } else if (joinCallButton) {
                console.log("Join video call button clicked!");
                const callId = joinCallButton.dataset.callId;
                // Use the imported load and initialize functions for joining
                try {
                    await loadJitsiScript();
                    initializeJitsiInstance(callId, currentUsername, jitsiContainer, onJitsiConferenceEnded, onJitsiConferenceError);
                } catch (error) {
                    console.error("Error joining video call:", error);
                    onJitsiConferenceError("Failed to join video call. Please try again.");
                }
            }
        });

        fullMediaCloseButton.addEventListener('click', closeFullMediaModal);

        // --- Initialization ---

        function getQueryParams() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const regex = /([^&=]+)=([^&]*)/g;
            let m;
            while ((m = regex.exec(queryString))) {
                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            return params;
        }

        const queryParams = getQueryParams();
        currentRoomCode = queryParams.room;
        currentUsername = queryParams.user;

        if (!currentRoomCode || !currentUsername) {
            alert('Room code or username missing. Redirecting to login.');
            window.location.href = 'index.html';
        } else {
            roomCodeDisplay.textContent = currentRoomCode;
            messagesRef = ref(db, `rooms/${currentRoomCode}/messages`);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    console.log("Authenticated with Firebase UID:", currentUserId);

                    await setupPresence();
                    updateOnlineUsersCount();

                    onValue(query(messagesRef, limitToLast(50), orderByChild('timestamp')), (snapshot) => {
                        messagesContainer.innerHTML = '';
                        snapshot.forEach((childSnapshot) => {
                            displayMessage(childSnapshot.val());
                        });
                        scrollToBottom();
                        loadingOverlay.classList.add('hidden');
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 300);
                    });

                    await push(messagesRef, {
                        type: 'system',
                        text: `${currentUsername} has joined the room.`,
                        timestamp: serverTimestamp()
                    });

                } else {
                    console.error("No user authenticated. Redirecting to login.");
                    alert('Authentication failed. Please log in again.');
                    window.location.href = 'index.html';
                }
            });
        }


        async function handleLeaveRoom() {
            console.log("Entering handleLeaveRoom function.");

            console.log("Proceeding to leave the room (no confirmation).");
            if (presenceRef && currentUserId) {
                console.log("presenceRef is valid:", presenceRef.toString());
                console.log("currentUserId is valid:", currentUserId);
                try {
                    await remove(presenceRef);
                    console.log("SUCCESS: User presence removed from room:", currentRoomCode);
                    await push(messagesRef, {
                        type: 'system',
                        text: `${currentUsername} has left the room.`,
                        timestamp: serverTimestamp()
                    });
                } catch (error) {
                    console.error("ERROR: Failed to remove presence on leave:", error);
                    alert("Failed to perform all leave operations. Check console for details, then you'll be redirected.");
                }
            } else {
                console.warn("WARNING: presenceRef or currentUserId not available. Cannot remove presence.");
            }
            // Use the imported hangUpCall function
            hangUpCall(onJitsiConferenceEnded);
            localStorage.removeItem('paritalk_username');
            localStorage.removeItem('paritalk_roomcode');
                console.log("Local storage cleared.");
            window.location.href = 'index.html';
            console.log("Redirecting to index.html...");
        }


        window.addEventListener('beforeunload', async (e) => {
            if (presenceRef && currentUserId) {
                console.log("Beforeunload event: Attempting to remove user presence explicitly.");
                try {
                    await set(presenceRef, null);
                    console.log("Presence explicitly removed on beforeunload.");
                } catch (error) {
                    console.error("Error explicitly removing presence on beforeunload:", error);
                }
            }
            // Use the imported hangUpCall function without direct UI callback
            hangUpCall(() => { /* no-op for beforeunload */ });
            localStorage.removeItem('paritalk_username');
            localStorage.removeItem('paritalk_roomcode');
            console.log("Local storage cleared on beforeunload.");
        });

    </script>
</body>
</html>
