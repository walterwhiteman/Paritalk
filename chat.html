<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paritalk - Chat Room</title>
    <!-- Google Fonts: Roboto (clean, modern, Apple-like feel) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Google Material Symbols (Premium Icon Feel) - CRITICAL LINE FOR ICONS -->
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <!-- Link to our custom styles.css - IMPORTANT: Stays in root as per your structure -->
    <link rel="stylesheet" href="style.css">

    <!-- Jitsi Meet External API - IMPORTANT: MUST be loaded as a regular script before module scripts use it -->
    <script src="https://meet.jit.si/external_api.js"></script>
</head>
<body>
    <div id="app-container" class="chat-app-container-premium">

        <!-- Chat Content Wrapper: This div holds all the main chat UI elements -->
        <!-- It will be hidden/shown by Jitsi video call logic -->
        <div id="chat-content-wrapper">
            <!-- Chat Header -->
            <header class="chat-header-premium">
                <div class="chat-header-info">
                    <span class="material-symbols-outlined chat-header-avatar-icon">person</span>
                    <div class="chat-header-details">
                        <h2 id="current-room-display" class="chat-room-display-name">Room: <span id="room-name"></span></h2>
                        <p id="online-users-count" class="chat-online-users-count">Online: 0</p>
                    </div>
                </div>
                <div class="chat-header-actions">
                    <span class="material-symbols-outlined chat-action-icon" id="video-call-button" title="Start Video Call">videocam</span>
                    <span class="material-symbols-outlined chat-action-icon" id="leave-room-button" title="Leave Room">logout</span>
                </div>
            </header>

            <!-- Message Area -->
            <main id="messages-container" class="messages-container-premium">
                <!-- Messages will be appended here -->
            </main>

            <!-- Typing Indicator -->
            <div id="typing-indicator" class="typing-indicator-premium hidden">
                <span>.</span><span>.</span><span>.</span>
            </div>

            <!-- Message Input Area -->
            <footer class="message-input-area-premium">
                <!-- File attachment button - MOVED TO LEFT -->
                <input type="file" id="image-upload" accept="image/*,video/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation" class="hidden">
                <label for="image-upload" title="Attach File" class="attach-file-button">
                    <span class="material-symbols-outlined">attach_file</span>
                </label>
                
                <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off">
                <button id="send-button" class="send-message-button">
                    <span class="material-symbols-outlined">send</span>
                </button>
            </footer>
        </div> <!-- End #chat-content-wrapper -->

        <!-- Jitsi Video Call Container -->
        <div id="jitsi-container" class="jitsi-container-premium hidden">
            <iframe id="jitsi-iframe" allow="camera; microphone; display-capture; autoplay; fullscreen"></iframe>
            <div id="jitsi-controls" class="jitsi-controls-premium">
                <button id="hangup-button" class="hangup-button-premium">
                    <span class="material-symbols-outlined">call_end</span> End Call
                </button>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmation-modal" class="modal-premium hidden">
            <div class="modal-content-premium">
                <p id="modal-message" class="modal-message-text-premium"></p>
                <div class="modal-actions-premium">
                    <button class="modal-button-premium cancel-button-premium" id="modal-cancel">
                        <span class="material-symbols-outlined">cancel</span>
                        <span>Cancel</span>
                    </button>
                    <button class="modal-button-premium confirm-button-premium" id="modal-confirm">
                        <span class="material-symbols-outlined">check_circle</span>
                        <span>Confirm</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Emoji Picker (hidden by default) - if needed, re-add in chat_main.js for visibility control -->
        <div id="emoji-picker" class="emoji-picker-premium hidden">
            <span class="emoji-option-premium">üëç</span>
            <span class="emoji-option-premium">‚ù§Ô∏è</span>
            <span class="emoji-option-premium">üòÇ</span>
            <span class="emoji-option-premium">üò≠</span>
            <span class="emoji-option-premium">üò°</span>
            <span class="emoji-option-premium">ü§î</span>
        </div>

    </div>

    <!-- Combined Firebase and Supabase JS - THIS BLOCK IS PRESERVED AND ADAPTED -->
    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getDatabase, ref, push, onChildAdded, onValue, set, remove, onDisconnect, serverTimestamp, runTransaction, child } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";


        // Supabase Client SDK Import
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // --- Firebase Configuration (YOUR ACTUAL CONFIG) ---
        const firebaseConfig = {
            apiKey: "AIzaSyA8Yj1Z1Mpv2lyt9SRxJ_w4U04BXt8hajk",
            authDomain: "paritalk.firebaseapp.com",
            databaseURL: "https://paritalk-default-rtdb.firebaseio.com",
            projectId: "paritalk",
            storageBucket: "paritalk.firebasestorage.app",
            messagingSenderId: "441945619664",
            appId: "1:441945619664:web:045e0c872e67e0eb9fb2d5"
        };
        const initialAuthToken = null; // Not used for GitHub Pages deployment.

        // Initialize Firebase
        let app;
        let auth;
        let db;
        let storage;

        try {
            if (firebaseConfig && firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.databaseURL) {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getDatabase(app);
                storage = getStorage(app);
                console.log("Firebase initialized successfully in chat.html.");
            } else {
                console.error("Firebase configuration is missing or empty in chat.html.");
                window.location.href = `index.html?error=${encodeURIComponent('App configuration error: Firebase is not set up correctly for chat.')}`;
                throw new Error("Firebase config missing for chat page.");
            }
        } catch (error) {
            console.error("Error during Firebase initialization in chat.html:", error.message);
            window.location.href = `index.html?error=${encodeURIComponent('Initialization error in chat. Please try again.')}`;
            throw error;
        }


        // Supabase Configuration (Using your confirmed URL and provided Anon Key)
        const SUPABASE_URL = 'https://uokpkgybjzvpngoxasnm.supabase.co'; // CONFIRMED CORRECT URL (ends with .co)
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVva3BrZ3lianp2cG5nb3hhc25tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5MjE4NTcsImV4cCI6MjA2NTQ5Nzg1N30.FNv_13S3oj7fjartmY2PzKL25T3AWbMxP2KRI0rFU2E';

        let supabase;
        try {
            if (SUPABASE_URL && SUPABASE_ANON_KEY) {
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized successfully with URL:", SUPABASE_URL);
            } else {
                console.warn('Supabase URL or Anon Key not set. File uploads will not work. Please ensure keys are correctly set.');
                supabase = null;
            }
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            supabase = null;
        }


        // Global variables for chat state
        let currentUserId = null;
        let currentUsername = '';
        let currentRoomCode = '';
        let roomRef = null;
        let presenceRef = null;
        let messagesRef = null;
        let typingRef = null;
        let jitsiApi = null;
        let typingTimeout = null;

        // UI Elements - UPDATED SELECTORS FOR PREMIUM DESIGN HTML
        const chatContentWrapper = document.getElementById('chat-content-wrapper');
        const roomNameDisplay = document.getElementById('room-name');
        const onlineUsersCountDisplay = document.getElementById('online-users-count');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const imageUploadInput = document.getElementById('image-upload');
        const videoCallButton = document.getElementById('video-call-button');
        const leaveRoomButton = document.getElementById('leave-room-button');
        const jitsiContainer = document.getElementById('jitsi-container');
        const jitsiIframe = document.getElementById('jitsi-iframe');
        const hangupButton = document.getElementById('hangup-button');
        const typingIndicator = document.getElementById('typing-indicator');

        // Emoji Picker elements
        const emojiPicker = document.getElementById('emoji-picker');
        let currentMessageElementForReaction = null;

        // Modal elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirm = document.getElementById('modal-confirm');
        const modalCancel = document.getElementById('modal-cancel');


        // Get Room Code and Username from URL
        const urlParams = new URLSearchParams(window.location.search);
        const urlRoomCode = urlParams.get('room');
        const urlUsername = urlParams.get('user');

        // If not logged in, redirect to index.html
        if (!urlRoomCode || !urlUsername) {
            console.warn("Room code or username missing from URL. Redirecting to login.");
            window.location.href = 'index.html';
        } else {
            currentRoomCode = decodeURIComponent(urlRoomCode);
            currentUsername = decodeURIComponent(urlUsername);
            if (roomNameDisplay) {
                roomNameDisplay.textContent = currentRoomCode;
            }
            if (chatContentWrapper) {
                 chatContentWrapper.classList.remove('hidden');
            }
        }

        // --- Helper Functions ---
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) {
                return '';
            }
            const options = { hour: 'numeric', minute: 'numeric', hour12: true };
            return date.toLocaleTimeString('en-US', options);
        }

        // --- Modal Functions ---
        let resolveModalPromise;

        function showModal(message, isConfirm = true) {
            if (!confirmationModal || !modalMessage || !modalConfirm || !modalCancel) {
                console.error("Modal elements not found. Cannot show modal.");
                return Promise.resolve(false);
            }

            modalMessage.textContent = message;

            if (isConfirm) {
                if (modalConfirm.querySelector('span:last-child')) modalConfirm.querySelector('span:last-child').textContent = 'Confirm';
                if (modalCancel.querySelector('span:last-child')) modalCancel.querySelector('span:last-child').textContent = 'Cancel';
                modalConfirm.classList.remove('hidden');
                modalCancel.classList.remove('hidden');
            } else {
                if (modalConfirm.querySelector('span:last-child')) modalConfirm.querySelector('span:last-child').textContent = 'OK';
                modalCancel.classList.add('hidden');
            }

            confirmationModal.classList.remove('hidden');

            return new Promise(resolve => {
                resolveModalPromise = resolve;
            });
        }

        function hideModal() {
            if (confirmationModal) {
                confirmationModal.classList.add('hidden');
            }
        }

        // --- Jitsi Service Functions ---
        let currentJitsiRoomName = '';

        function initializeJitsiInChat() {
            currentJitsiRoomName = `Paritalk_${currentRoomCode}`;
            
            if (hangupButton) {
                hangupButton.onclick = () => {
                    endVideoCall();
                };
            } else {
                console.error("Hangup button not found!");
            }
        }


        function startVideoCall() {
            if (jitsiApi) {
                console.log("Jitsi call already active.");
                return;
            }

            const domain = 'meet.jit.si';
            const options = {
                roomName: currentJitsiRoomName,
                width: '100%',
                height: '100%',
                parentNode: jitsiIframe.parentNode,
                userInfo: {
                    displayName: currentUsername
                },
                configOverwrite: {
                    startWithAudioMuted: false,
                    startWithVideoMuted: false,
                    enableWelcomePage: false,
                    prejoinPageEnabled: false,
                    toolbarButtons: ['microphone', 'camera', 'desktop', 'fullscreen', 'fodeviceselection', 'hangup', 'profile', 'chat', 'raisehand', 'tileview', 'mute-everyone', 'security', 'settings', 'shortcuts', 'subject', 'toggle-camera']
                },
                interfaceConfigOverwrite: {
                    APP_NAME: 'Paritalk Video Call',
                    HIDE_INVITE_MORE_TOOLBAR_BUTTON: true,
                    SHOW_JITSI_WATERMARK: false,
                    SHOW_WATERMARK_FOR_GUESTS: false,
                    SHOW_BRAND_WATERMARK: false,
                    SHOW_CHROME_EXTENSION_BANNER: false,
                    TOOLBAR_ALWAYS_VISIBLE: true,
                }
            };

            jitsiApi = new JitsiMeetExternalAPI(domain, options);

            jitsiApi.addEventListener('readyToClose', () => {
                console.log('Jitsi API ready to close event fired.');
                endVideoCall();
            });
            jitsiApi.addEventListener('participantLeft', (participant) => {
                console.log('Jitsi Participant Left:', participant);
            });

            if (jitsiContainer) {
                jitsiContainer.classList.remove('hidden');
            }
            if (chatContentWrapper) {
                chatContentWrapper.classList.add('hidden');
            }
        }

        function endVideoCall() {
            if (jitsiApi) {
                jitsiApi.dispose();
                jitsiApi = null;
            }

            if (jitsiContainer) {
                jitsiContainer.classList.add('hidden');
            }
            if (chatContentWrapper) {
                chatContentWrapper.classList.remove('hidden');
            }
        }

        function getJitsiApi() {
            return jitsiApi;
        }


        // --- Message Display Logic ---
        function addMessageToChat(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message-bubble-premium');

            let contentHTML = '';

            if (message.type === 'system') {
                messageElement.classList.add('system-message-premium');
                messageElement.textContent = message.text;
                messagesContainer.appendChild(messageElement);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                return;
            }

            const isMine = message.sender === currentUsername;
            messageElement.classList.add(isMine ? 'mine-bubble-premium' : 'other-bubble-premium');

            if (message.type === 'text') {
                contentHTML += `<p class="message-content-premium">${message.text}</p>`;
            } else if (message.type === 'image') {
                contentHTML += `
                    <div class="message-image-preview">
                        <img src="${message.imageUrl}" alt="Shared Image Preview" class="message-image-premium-thumb" onerror="this.onerror=null;this.src='https://placehold.co/100x70/eeeeee/aaaaaa?text=Image';">
                        <span class="material-symbols-outlined message-media-overlay-icon">zoom_in</span>
                    </div>
                `;
            } else if (message.type === 'file') {
                let fileIcon = 'description';
                const fileExtension = message.fileName ? message.fileName.split('.').pop().toLowerCase() : '';
                if (['pdf'].includes(fileExtension)) fileIcon = 'picture_as_pdf';
                else if (['doc', 'docx'].includes(fileExtension)) fileIcon = 'article';
                else if (['xls', 'xlsx'].includes(fileExtension)) fileIcon = 'grid_on';
                else if (['ppt', 'pptx'].includes(fileExtension)) fileIcon = 'slideshow';
                else if (['zip', 'rar', '7z'].includes(fileExtension)) fileIcon = 'folder_zip';
                else if (['mp3', 'wav', 'ogg'].includes(fileExtension)) fileIcon = 'audio_file';
                else if (['mp4', 'mov', 'avi'].includes(fileExtension)) fileIcon = 'videocam';

                contentHTML += `
                    <div class="message-file-premium-preview">
                        <span class="material-symbols-outlined file-icon">${fileIcon}</span>
                        <a href="${message.fileUrl}" target="_blank" class="file-name-link">${message.fileName}</a>
                        <a href="${message.fileUrl}" download="${message.fileName}" class="download-icon" title="Download">
                            <span class="material-symbols-outlined">download</span>
                        </a>
                    </div>
                `;
            }

            // NEW: Combine sender name and timestamp at the bottom
            contentHTML += `
                <div class="message-info-footer-premium">
                    <span class="message-sender-name-bottom">${message.sender}</span>
                    <span class="message-timestamp-premium">${formatTimestamp(message.timestamp)}</span>
                </div>
            `;

            messageElement.innerHTML = contentHTML;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Event listener for opening full view of images/files
            if (message.type === 'image' || message.type === 'file') {
                const mediaPreview = messageElement.querySelector('.message-image-preview') || messageElement.querySelector('.message-file-premium-preview');
                if (mediaPreview) {
                    mediaPreview.style.cursor = 'pointer';
                    mediaPreview.addEventListener('click', (event) => {
                        // Prevent click on download icon from also opening the modal
                        if (event.target.closest('.download-icon')) {
                            return;
                        }
                        if (message.type === 'image') {
                            showFullMediaModal(message.type, message.imageUrl, message.fileName);
                        } else {
                            showFullMediaModal(message.type, message.fileUrl, message.fileName);
                        }
                    });
                }
            }
        }

        // --- Full Media View Modal Logic (Dynamically created and appended) ---
        const fullMediaModal = document.createElement('div');
        fullMediaModal.id = 'full-media-modal';
        fullMediaModal.classList.add('full-media-modal-premium', 'hidden'); // Ensure hidden by default
        fullMediaModal.innerHTML = `
            <div class="full-media-content-premium">
                <button class="full-media-close-button">
                    <span class="material-symbols-outlined">close</span>
                </button>
                <div class="full-media-display-area">
                    <!-- Media will be dynamically inserted here -->
                </div>
                <div class="full-media-controls">
                    <a id="full-media-download-link" href="#" download class="full-media-download-button">
                        <span class="material-symbols-outlined">download</span> Download
                    </a>
                </div>
            </div>
        `;
        document.addEventListener('DOMContentLoaded', () => {
            document.body.appendChild(fullMediaModal);
        });

        const fullMediaDisplayArea = fullMediaModal.querySelector('.full-media-display-area');
        const fullMediaCloseButton = fullMediaModal.querySelector('.full-media-close-button');
        const fullMediaDownloadLink = fullMediaModal.querySelector('#full-media-download-link');

        if (fullMediaCloseButton) {
            fullMediaCloseButton.addEventListener('click', () => {
                fullMediaModal.classList.add('hidden');
                fullMediaDisplayArea.innerHTML = '';
            });
        }


        function showFullMediaModal(type, url, fileName) {
            fullMediaDisplayArea.innerHTML = '';
            fullMediaDownloadLink.href = url;
            fullMediaDownloadLink.download = fileName || 'download';

            const existingVideo = fullMediaDisplayArea.querySelector('video');
            if (existingVideo) {
                existingVideo.pause();
                existingVideo.removeAttribute('src');
                existingVideo.load();
                fullMediaDisplayArea.removeChild(existingVideo);
            }

            if (type === 'image') {
                const img = document.createElement('img');
                img.src = url;
                img.alt = fileName || "Full size image";
                img.classList.add('full-media-image');
                fullMediaDisplayArea.appendChild(img);
            } else if (type === 'file') {
                const fileExtension = fileName ? fileName.split('.').pop().toLowerCase() : '';
                if (['mp4', 'mov', 'avi', 'webm'].includes(fileExtension)) {
                    const video = document.createElement('video');
                    video.src = url;
                    video.controls = true;
                    video.autoplay = true;
                    video.classList.add('full-media-video');
                    fullMediaDisplayArea.appendChild(video);
                } else if (['pdf'].includes(fileExtension)) {
                    const iframe = document.createElement('iframe');
                    iframe.src = url;
                    iframe.classList.add('full-media-document');
                    iframe.frameBorder = "0";
                    fullMediaDisplayArea.appendChild(iframe);
                } else {
                    const p = document.createElement('p');
                    p.textContent = `Preview not available for ${fileExtension.toUpperCase()} files.`;
                    p.classList.add('full-media-info-text');
                    fullMediaDisplayArea.appendChild(p);
                }
            }
            fullMediaModal.classList.remove('hidden');
        }

        // --- Send Message Logic ---
        async function sendMessage(text, type = 'text', imageUrl = null, fileUrl = null, fileName = null) {
            if (!currentUserId || !currentRoomCode || !messagesRef) {
                console.error("Chat references not initialized. Cannot send message.");
                return;
            }

            const message = {
                sender: currentUsername,
                timestamp: serverTimestamp(),
                type: type,
            };

            if (type === 'text') {
                message.text = text;
            } else if (type === 'image') {
                message.imageUrl = imageUrl;
                message.text = 'Image';
            } else if (type === 'file') {
                message.fileUrl = fileUrl;
                message.fileName = fileName;
                message.text = 'File';
            } else if (type === 'system') {
                message.text = text;
            }


            try {
                await push(messagesRef, message);
                messageInput.value = '';
                if (typingRef) {
                    set(typingRef, false);
                }
            } catch (error) {
                console.error("Error sending message to Firebase:", error);
                showModal('Failed to send message: ' + error.message, false);
            }
        }

        // --- File Upload Logic ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!supabase) {
                showModal('Supabase is not configured. File uploads are disabled.', false);
                console.error('Supabase client is not initialized. Please configure SUPABASE_URL and SUPABASE_ANON_KEY.');
                return;
            }
            if (!currentRoomCode || !currentUserId) {
                console.error("Room code or user ID is missing. Cannot upload file. currentRoomCode:", currentRoomCode, "currentUserId:", currentUserId);
                showModal('Cannot upload file: Room information missing. Please rejoin chat.', false);
                return;
            }

            const filePath = `${currentRoomCode}/${currentUserId}/${Date.now()}_${file.name}`;
            const fileType = file.type;

            try {
                addMessageToChat({
                    sender: 'System',
                    text: `Uploading "${file.name}"...`,
                    type: 'system',
                    timestamp: Date.now()
                });

                const { data, error } = await supabase.storage
                    .from('parichat-files')
                    .upload(filePath, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (error) {
                    console.error("Supabase upload error:", error);
                    throw error;
                }

                const { data: publicUrlData, error: publicUrlError } = supabase.storage
                    .from('parichat-files')
                    .getPublicUrl(filePath);

                if (publicUrlError) {
                    console.error("Supabase getPublicUrl error:", publicUrlError);
                    throw publicUrlError;
                }
                if (!publicUrlData || !publicUrlData.publicUrl) {
                    throw new Error('Failed to get public URL for the uploaded file.');
                }

                if (fileType.startsWith('image/') || fileType.startsWith('video/')) {
                    await sendMessage('', fileType.startsWith('image/') ? 'image' : 'file', publicUrlData.publicUrl, null, file.name);
                } else {
                    await sendMessage('', 'file', null, publicUrlData.publicUrl, file.name);
                }

            } catch (error) {
                    console.error("Final Error in handleFileUpload:", error);
                    addMessageToChat({
                        sender: 'System',
                        text: `Failed to upload "${file.name}": ${error.message}. Please check Supabase URL, Anon Key, and Storage Bucket/Policies.`,
                        type: 'system',
                        timestamp: Date.now()
                    });
            } finally {
                imageUploadInput.value = '';
            }
        }

        // --- Firebase Listeners and Presence Logic ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                if (!currentRoomCode || !currentUsername) {
                    console.error("Room code or username missing after auth. Cannot set up Firebase refs.");
                    showModal('Critical Error: Room details missing. Please re-join.', false).then(() => {
                        window.location.href = 'index.html';
                    });
                    return;
                }

                roomRef = ref(db, `rooms/${currentRoomCode}`);
                presenceRef = ref(db, `rooms/${currentRoomCode}/presence/${currentUserId}`);
                messagesRef = ref(db, `rooms/${currentRoomCode}/messages`);
                typingRef = ref(db, `rooms/${currentRoomCode}/typing/${currentUserId}`);

                try {
                    await set(presenceRef, { username: currentUsername, lastSeen: serverTimestamp() });
                    onDisconnect(presenceRef).remove();

                    if (!localStorage.getItem('paritalk_joined_message_sent_for_' + currentRoomCode + currentUsername)) {
                        console.log("Sending 'joined' message...");
                        sendMessage(`**${currentUsername}** joined the chat.`, 'system');
                        localStorage.setItem('paritalk_joined_message_sent_for_' + currentRoomCode + currentUsername, 'true');
                    }

                    listenForMessages();
                    listenForPresence();
                    listenForTyping();

                    messageInput.focus();

                    initializeJitsiInChat();

                } catch (error) {
                    console.error("Error setting up chat listeners/presence:", error);
                    localStorage.removeItem('paritalk_username');
                    localStorage.removeItem('paritalk_roomcode');
                    localStorage.removeItem('paritalk_joined_message_sent_for_' + currentRoomCode + currentUsername);
                    showModal('Failed to set up chat. Please re-join. Error: ' + error.message, false).then(() => {
                        window.location.href = 'index.html';
                    });
                }
            } else {
                console.warn("User not authenticated in chat.html. Redirecting to login.");
                window.location.href = 'index.html?error=' + encodeURIComponent('Authentication failed. Please re-login.');
            }
        });

        function listenForMessages() {
            onChildAdded(messagesRef, (snapshot) => {
                const message = snapshot.val();
                addMessageToChat(message);
            });
        }

        function listenForPresence() {
            const roomPresenceRef = ref(db, `rooms/${currentRoomCode}/presence`);
            onValue(roomPresenceRef, (snapshot) => {
                const users = [];
                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    if (userData.username) {
                        users.push(userData.username);
                    }
                });

                if (onlineUsersCountDisplay) {
                    onlineUsersCountDisplay.textContent = `Online: ${users.length}`;
                }

                const currentJitsiApi = getJitsiApi();
                if (currentJitsiApi) {
                    const jitsiParticipantsCount = currentJitsiApi.getNumberOfParticipants ? currentJitsiApi.getNumberOfParticipants() : 0;
                    const firebaseOtherUsersCount = users.filter(u => u !== currentUsername).length;

                    if (firebaseOtherUsersCount === 0 && jitsiParticipantsCount <= 1 && users.includes(currentUserId)) {
                        console.log("Other user left room (Firebase) and Jitsi, ending call.");
                        endVideoCall();
                        addMessageToChat({
                            sender: 'System',
                            text: 'The other user has left the call, ending the video session.',
                            type: 'system',
                            timestamp: Date.now()
                        });
                    }
                }
            });
        }

        async function handleLeaveRoom() {
            const confirmed = await showModal('Are you sure you want to leave the chat?', true);
            if (confirmed) {
                const currentJitsiApi = getJitsiApi();
                if (currentJitsiApi) {
                    endVideoCall();
                }
                if (presenceRef) {
                    console.log("Leaving room: Explicitly removing user presence.");
                    await remove(presenceRef);
                    sendMessage(`**${currentUsername}** left the chat.`, 'system');
                }
                localStorage.removeItem('paritalk_username');
                localStorage.removeItem('paritalk_roomcode');
                localStorage.removeItem('paritalk_joined_message_sent_for_' + currentRoomCode + currentUsername);

                window.location.href = 'index.html';
            }
            hideModal();
        }

        function setTypingStatus(isTyping) {
            if (typingRef) {
                set(typingRef, isTyping);
            }
        }

        function listenForTyping() {
            const allTypingRef = ref(db, `rooms/${currentRoomCode}/typing`);
            onValue(allTypingRef, (snapshot) => {
                const typingUsers = [];
                snapshot.forEach((childSnapshot) => {
                    if (childSnapshot.val() === true && childSnapshot.key !== currentUserId) {
                        const presenceSnapshot = snapshot.child(`../presence/${childSnapshot.key}`);
                        if (presenceSnapshot.exists() && presenceSnapshot.val().username) {
                            typingUsers.push(presenceSnapshot.val().username);
                        } else {
                            typingUsers.push('Someone');
                        }
                    }
                });

                if (typingUsers.length > 0) {
                    let displayString = '';
                    if (typingUsers.length === 1) {
                        displayString = `${typingUsers[0]} is typing`;
                    } else if (typingUsers.length === 2) {
                        displayString = `${typingUsers[0]} and ${typingUsers[1]} are typing`;
                    } else {
                        displayString = `Multiple people are typing`;
                    }
                    typingIndicator.textContent = `${displayString}...`;
                    typingIndicator.classList.remove('hidden');
                } else {
                    typingIndicator.classList.add('hidden');
                }
            });
        }

        // --- Event Listeners ---
        messageInput.addEventListener('input', () => {
            setTypingStatus(true);
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                setTypingStatus(false);
            }, 2000);
        });

        messageInput.addEventListener('blur', () => {
            if (messageInput.value.trim() === '') {
                 setTypingStatus(false);
                 clearTimeout(typingTimeout);
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const messageText = messageInput.value.trim();
                if (messageText) {
                    sendMessage(messageText, 'text');
                }
            }
        });

        sendButton.addEventListener('click', () => {
            const messageText = messageInput.value.trim();
            if (messageText) {
                sendMessage(messageText, 'text');
            }
        });

        imageUploadInput.addEventListener('change', handleFileUpload);

        if (videoCallButton) {
            videoCallButton.addEventListener('click', startVideoCall);
            console.log("Video Call button event listener attached.");
        } else {
            console.error("Video Call button element not found!");
        }

        if (leaveRoomButton) {
            leaveRoomButton.addEventListener('click', handleLeaveRoom);
            console.log("Leave Room button event listener attached.");
        } else {
            console.error("Leave Room button element not found!");
        }

        if (hangupButton) {
            hangupButton.addEventListener('click', () => {
                endVideoCall();
            });
        }

        if (modalConfirm) {
            modalConfirm.addEventListener('click', () => {
                if (resolveModalPromise) resolveModalPromise(true);
                hideModal();
            });
        } else { console.error("Modal Confirm button not found!"); }
        
        if (modalCancel) {
            modalCancel.addEventListener('click', () => {
                if (resolveModalPromise) resolveModalPromise(false);
                hideModal();
            });
        } else { console.error("Modal Cancel button not found!"); }


        window.addEventListener('beforeunload', async (e) => {
            if (presenceRef && currentUserId) {
                console.log("Beforeunload: Attempting to remove user presence explicitly.");
                await set(presenceRef, null);
                if (jitsiApi) {
                    jitsiApi.dispose();
                }
            }
        });

        document.addEventListener('click', (event) => {
            if (emojiPicker && !emojiPicker.classList.contains('hidden') && !emojiPicker.contains(event.target) && !event.target.closest('.message-bubble-premium')) {
                emojiPicker.classList.add('hidden');
            }
        });

    </script>
</body>
</html>
